{"version":3,"sources":["webpack://react-app/./src/images/classification/Sample 1.jpeg","webpack://react-app/./src/images/classification/Sample 2.jpeg","webpack://react-app/./src/images/classification/Sample 3.jpeg","webpack://react-app/./src/components/DropArea.jsx","webpack://react-app/./src/components/ImageClassifier.jsx"],"names":["DragBox","styled","maxImageNumber","imagesAtom","atom","key","default","sample1","sample2","sample3","filenamesAtom","DropArea","useRecoilState","images","setImages","setFilenames","useState","err","setErr","container","useRef","handleFileChosen","file","Promise","resolve","reject","fileReader","FileReader","onload","result","onerror","readAsDataURL","readAllFiles","AllFiles","all","map","fileContents","length","slice","Math","max","results","loadImageUrl","url","im","Image","src","crossOrigin","console","log","onDrop","e","preventDefault","imageUrl","dataTransfer","getData","files","size","type","includes","Array","from","newFilenames","i","name","push","filenames","onDragEnter","onDragLeave","onDragOver","inputUrl","setInputUrl","useEffect","current","div","addEventListener","removeEventListener","ref","onSubmit","style","whiteSpace","value","onChange","target","className","marginTop","onClick","model","loadModel","tf","predictionsAtom","ImageClassifier","useRecoilValue","predictions","setPredictions","previousNumberOfImages","setPreviousNumberOfImages","predict","image","img","tensorImg","resizeNearestNeighbor","toFloat","expandDims","data","prediction","then","values","Date","now"],"mappings":"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","file":"934.xxxxxxxx.bundle.js","sourcesContent":["export default __webpack_public_path__ + \"4081ba9e5e0af1f0a479660d34c6a431.jpeg\";","export default __webpack_public_path__ + \"59293c1b870db44806de02ebe5c55c71.jpeg\";","export default __webpack_public_path__ + \"b50af27e4815f2aca04b67a055bc5b2d.jpeg\";","import React, { useEffect, useState, useRef } from \"react\";\nimport {\n  useRecoilState,\n  atom\n} from \"recoil\";\nimport styled from \"styled-components\"\n\nimport sample1 from \"images/classification/Sample 1.jpeg\"\nimport sample2 from \"images/classification/Sample 2.jpeg\"\nimport sample3 from \"images/classification/Sample 3.jpeg\"\n\nconst width = \"300px\";\nconst height = \"300px\";\nconst borderStyle = \"2px dotted #000\";\n\nconst DragBox = styled.div`\n  width: ${width};\n  height: ${height};\n  border: ${borderStyle};\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  font-size: 20px;\n  white-space: pre-line;\n`\n\nconst maxImageNumber = 30\n\nconst imagesAtom = atom({\n  key: 'images',\n  default: [sample1, sample2, sample3]\n})\nconst filenamesAtom = atom({\n  key: 'filenames',\n  default: [\"Sample 1.jpeg\", \"Sample 2.jpeg\", \"Sample 3.jpeg\"]\n})\n\nconst DropArea = () => {\n  const [images, setImages] = useRecoilState(imagesAtom)\n  const [filenames, setFilenames] = useRecoilState(filenamesAtom)\n  const [err, setErr] = useState(false)\n\n  const container = useRef(null);\n\n\n  const handleFileChosen = async (file) => {\n    return new Promise((resolve, reject) => {\n      let fileReader = new FileReader();\n      fileReader.onload = () => {\n        resolve(fileReader.result);\n      };\n      fileReader.onerror = reject;\n      fileReader.readAsDataURL(file);\n    });\n  }\n\n\n  const readAllFiles = async (AllFiles) => {\n    const results = await Promise.all(AllFiles.map(async (file) => {\n      const fileContents = await handleFileChosen(file);\n      setImages(images => {\n        let length = images.length + 1\n        if (length > maxImageNumber) {\n          return images\n        }\n        return [...images, fileContents].slice(Math.max(length - maxImageNumber, 0))\n      });\n      return fileContents;\n    }));\n    return results;\n  }\n\n  const loadImageUrl = async (url) => {\n    return new Promise((resolve, reject) => {\n      const im = new Image()\n      im.src = url\n      im.crossOrigin = 'anonymous'\n      im.onload = () => {\n        resolve(im)\n\n        setImages(images => {\n          let length = images.length + 1\n          if (length > maxImageNumber) {\n            return images\n          }\n          return [...images, url].slice(Math.max(length - maxImageNumber, 0))\n        });\n        setErr(\"\")\n      }\n      im.onerror = () => {\n        console.log(\"onerror\")\n        reject(im)\n\n        setErr(\"File format must be either png or jpg, not hyperlink or else!\");\n      }\n    })\n  }\n\n  /* Input by drag and drop */\n\n  const onDrop = (e) => {\n    e.preventDefault();\n\n    const imageUrl = e.dataTransfer.getData('url')\n    const {\n      dataTransfer: { files },\n    } = e;\n\n    console.log(\"imageUrl: \", imageUrl)\n    console.log(\"files: \", files);\n\n    /* If user is dragging online image from another window, directly process and return */\n    if (imageUrl !== null && imageUrl.length !== 0) {\n      loadImageUrl(imageUrl)\n    }\n\n    const { length } = files;\n\n    if (length === 0) {\n      return false;\n    }\n    const fileTypes = [\n      \"image/jpeg\",\n      \"image/jpg\",\n      \"image/png\",\n      // \"image/gif\",\n      // \"image/x-icon\",\n    ];\n    const { size, type } = files[0];\n\n    if (!fileTypes.includes(type)) {\n      setErr(\"File format must be either png or jpg\");\n      return false;\n    }\n    if (size / 1024 / 1024 > 2) {\n      setErr(\"File size exceeded the limit of 2MB\");\n      return false;\n    }\n    setErr(false);\n\n    console.log(readAllFiles(Array.from(files)))\n\n    // Retrieve and save filenames\n    var newFilenames = []\n    for (var i = 0; i < files.length; i++) {\n      if (!files[i].name) return;\n      newFilenames.push(files[i].name);\n    }\n    setFilenames(filenames => {\n      let length = filenames.length + newFilenames.length\n      if (length > maxImageNumber) {\n        return filenames\n      }\n      return [...filenames, ...newFilenames].slice(Math.max(length - maxImageNumber, 0))\n    });\n  };\n  const onDragEnter = (e) => {\n    console.log(\"onDragEnter\");\n    e.preventDefault();\n  };\n  const onDragLeave = (e) => {\n    console.log(\"onDragLeave\");\n    e.preventDefault();\n  };\n  const onDragOver = (e) => {\n    console.log(\"onDragOver\");\n    e.preventDefault();\n  };\n\n  /* Input by input URL */\n  const [inputUrl, setInputUrl] = useState('')\n  const handleChangeUrl = (e) => {\n    setInputUrl(e.target.value)\n  }\n  const handleSubmitUrl = (e) => {\n    e.preventDefault()\n    loadImageUrl(inputUrl)\n  }\n\n  useEffect(() => {\n    console.log(\"DropArea useEffect is called\");\n\n    if (container.current) {\n      let div = container.current;\n      div.addEventListener(\"dragenter\", onDragEnter);\n      div.addEventListener(\"dragleave\", onDragLeave);\n      div.addEventListener(\"dragover\", onDragOver);\n      div.addEventListener(\"drop\", onDrop);\n    }\n    return () => {\n      /* This if condition prevents null error, it needs to be inside \"return\". */\n      if (container.current) {\n        let div = container.current;\n        div.removeEventListener(\"dragenter\", onDragEnter);\n        div.removeEventListener(\"dragleave\", onDragLeave);\n        div.removeEventListener(\"dragover\", onDragOver);\n        div.removeEventListener(\"drop\", onDrop);\n      }\n    };\n    /* Usually it is good to include \"container.current\" in the dependency array, this time it is also\n    good to not include it so that useEffect is only executed once at the beginning instead of twice. */\n  }, []);\n\n  return (\n    <div>\n      {err && <p>{err}</p>}\n      <DragBox ref={container}>\n        {\"Drag images here (from local\\n\\nfilesystem or browser window)\"}\n      </DragBox>\n      <form onSubmit={handleSubmitUrl}>\n        <label style={{whiteSpace: \"pre\"}}>\n          {\"Image URL:  \"}\n          <input type=\"text\" value={inputUrl} onChange={handleChangeUrl} />\n        </label>\n        <input type=\"submit\" value=\"Submit\" />\n      </form>\n      <div className=\"button-wrapper\" style={{ marginTop: \"15px\" }}>\n        {images && <button onClick={() => {\n          setImages([])\n          setFilenames([])\n        }}>Remove All</button>}\n      </div>\n      <h5 style={{ marginTop: \"20px\" }}>Maximum {maxImageNumber} images</h5>\n    </div>\n  );\n};\nexport { DropArea as default, imagesAtom, filenamesAtom };\n","import React, { useEffect, useState } from \"react\";\nimport * as tf from '@tensorflow/tfjs';\nimport {\n    useRecoilState,\n    atom,\n    useRecoilValue,\n} from \"recoil\";\nimport { imagesAtom } from \"components/DropArea\"\n\nvar model\nvar images\n\nconst loadModel = async () => {\n    model = await tf.loadLayersModel('https://cnn-repo.s3.ap-east-1.amazonaws.com/models/tfjs/model.json')\n    console.log(model)\n    return model\n}\n\nconst loadImageUrl = async (url) => {\n    return new Promise((resolve, reject) => {\n        const im = new Image()\n        im.src = url\n        im.crossOrigin = 'anonymous'\n        im.onload = () => {\n            resolve(im)\n        }\n    })\n}\n\nconst predictionsAtom = atom({\n    key: 'predictions',\n    default: []\n})\n\nconst ImageClassifier = () => {\n    images = useRecoilValue(imagesAtom)\n    const [predictions, setPredictions] = useRecoilState(predictionsAtom)\n\n    const [previousNumberOfImages, setPreviousNumberOfImages] = useState(0)\n\n    const predict = async (images) => {\n        console.log(\"predict\")\n        console.log(images.slice(previousNumberOfImages))\n\n        await Promise.all(images.slice(previousNumberOfImages).map(async (image) => {\n            const img = await loadImageUrl(image)\n            const tensorImg = tf.browser.fromPixels(img).resizeNearestNeighbor([224, 224]).toFloat().expandDims();\n            const prediction = await model.predict(tensorImg).data();\n            return prediction\n        })).then((values) => {\n            if (images.length == 0 || images.length < predictions.length) {\n                setPredictions(values)\n            }\n            else {\n                setPredictions([...predictions, ...values])\n            }\n\n            setPreviousNumberOfImages(images.length)\n\n            console.log(\"Time: \" + Date.now())\n        })\n    }\n\n    useEffect(() => {\n        if (model) {\n            console.log(\"Time: \" + Date.now())\n            predict(images)\n            console.log(tf.getBackend())\n        }\n        else {\n            loadModel().then(() => {\n                /* In case the user drag images earlier than model load */\n                predict(images)\n            })\n        }\n    }, [images])\n\n    return (\n        <div></div>\n    )\n}\n\nexport { ImageClassifier as default, predictionsAtom };"],"sourceRoot":""}