{"version":3,"sources":["webpack://react-app/./src/images/classification/Sample 1.jpeg","webpack://react-app/./src/images/classification/Sample 2.jpeg","webpack://react-app/./src/images/classification/Sample 3.jpeg","webpack://react-app/./src/components/DropArea.jsx","webpack://react-app/./src/components/ImageClassifier.jsx"],"names":["DragBox","styled","imagesAtom","atom","key","default","sample1","sample2","sample3","filenamesAtom","DropArea","useRecoilState","images","setImages","setFilenames","useState","err","setErr","container","useRef","handleFileChosen","file","Promise","resolve","reject","fileReader","FileReader","onload","result","onerror","readAsDataURL","readAllFiles","AllFiles","all","map","fileContents","length","slice","Math","max","results","onDrop","e","preventDefault","files","dataTransfer","console","log","size","type","includes","Array","from","newFilenames","i","name","push","filenames","onDragEnter","onDragLeave","onDragOver","useEffect","current","div","addEventListener","removeEventListener","ref","className","onClick","style","marginTop","model","loadModel","tf","loadImageUrl","url","im","Image","src","predictionsAtom","ImageClassifier","useRecoilValue","setPredictions","predict","image","img","tensorImg","resizeNearestNeighbor","toFloat","expandDims","data","prediction","then","values"],"mappings":"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","file":"934.xxxxxxxx.bundle.js","sourcesContent":["export default __webpack_public_path__ + \"4081ba9e5e0af1f0a479660d34c6a431.jpeg\";","export default __webpack_public_path__ + \"59293c1b870db44806de02ebe5c55c71.jpeg\";","export default __webpack_public_path__ + \"b50af27e4815f2aca04b67a055bc5b2d.jpeg\";","import React, { useEffect, useState, useRef } from \"react\";\nimport {\n  useRecoilState,\n  atom\n} from \"recoil\";\nimport styled from \"styled-components\"\n\nimport sample1 from \"images/classification/Sample 1.jpeg\"\nimport sample2 from \"images/classification/Sample 2.jpeg\"\nimport sample3 from \"images/classification/Sample 3.jpeg\"\n\nconst width = \"300px\";\nconst height = \"300px\";\nconst borderStyle = \"2px dotted #000\";\n\nconst DragBox = styled.div`\n  width: ${width};\n  height: ${height};\n  border: ${borderStyle};\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  font-size: 20px;\n`\n\nconst maxImageNumber = 8\n\nconst imagesAtom = atom({\n  key: 'images',\n  default: [sample1, sample2, sample3]\n})\nconst filenamesAtom = atom({\n  key: 'filenames',\n  default: [\"Sample 1.jpeg\", \"Sample 2.jpeg\", \"Sample 3.jpeg\"]\n})\n\nconst DropArea = () => {\n  const [images, setImages] = useRecoilState(imagesAtom)\n  const [filenames, setFilenames] = useRecoilState(filenamesAtom)\n  const [err, setErr] = useState(false)\n\n  const container = useRef(null);\n\n\n  const handleFileChosen = async (file) => {\n    return new Promise((resolve, reject) => {\n      let fileReader = new FileReader();\n      fileReader.onload = () => {\n        resolve(fileReader.result);\n      };\n      fileReader.onerror = reject;\n      fileReader.readAsDataURL(file);\n    });\n  }\n\n\n  const readAllFiles = async (AllFiles) => {\n    const results = await Promise.all(AllFiles.map(async (file) => {\n      const fileContents = await handleFileChosen(file);\n      setImages(images => {\n        let length = images.length + 1\n        return [...images, fileContents].slice(Math.max(length - maxImageNumber, 0))\n      });\n      return fileContents;\n    }));\n    return results;\n  }\n\n\n\n  const onDrop = (e) => {\n    e.preventDefault();\n    const {\n      dataTransfer: { files },\n    } = e;\n    console.log(\"Files: \", files);\n    const { length } = files;\n\n    if (length === 0) {\n      return false;\n    }\n    const fileTypes = [\n      \"image/jpeg\",\n      \"image/jpg\",\n      \"image/png\",\n      // \"image/gif\",\n      // \"image/x-icon\",\n    ];\n    const { size, type } = files[0];\n\n    if (!fileTypes.includes(type)) {\n      setErr(\"File format must be either png or jpg\");\n      return false;\n    }\n    if (size / 1024 / 1024 > 2) {\n      setErr(\"File size exceeded the limit of 2MB\");\n      return false;\n    }\n    setErr(false);\n\n    console.log(readAllFiles(Array.from(files)))\n\n    // Retrieve and save filenames\n    var newFilenames = []\n    for (var i = 0; i < files.length; i++) {\n      if (!files[i].name) return;\n      newFilenames.push(files[i].name);\n    }\n    setFilenames(filenames => {\n      let length = filenames.length + newFilenames.length\n      return [...filenames, ...newFilenames].slice(Math.max(length - maxImageNumber, 0))\n    });\n  };\n  const onDragEnter = (e) => {\n    console.log(\"onDragEnter\");\n    e.preventDefault();\n  };\n  const onDragLeave = (e) => {\n    console.log(\"onDragLeave\");\n    e.preventDefault();\n  };\n  const onDragOver = (e) => {\n    console.log(\"onDragOver\");\n    e.preventDefault();\n  };\n\n  useEffect(() => {\n    console.log(\"DropArea useEffect is called\");\n\n    if (container.current) {\n      let div = container.current;\n      div.addEventListener(\"dragenter\", onDragEnter);\n      div.addEventListener(\"dragleave\", onDragLeave);\n      div.addEventListener(\"dragover\", onDragOver);\n      div.addEventListener(\"drop\", onDrop);\n    }\n    return () => {\n      /* This if condition prevents null error, it needs to be inside \"return\". */\n      if (container.current) {\n        let div = container.current;\n        div.removeEventListener(\"dragenter\", onDragEnter);\n        div.removeEventListener(\"dragleave\", onDragLeave);\n        div.removeEventListener(\"dragover\", onDragOver);\n        div.removeEventListener(\"drop\", onDrop);\n      }\n    };\n    /* Usually it is good to include \"container.current\" in the dependency array, this time it is also\n    good to not include it so that useEffect is only executed once at the beginning instead of twice. */\n  }, []);\n\n  return (\n    <div>\n      {err && <p>{err}</p>}\n      <DragBox ref={container}>\n        Drag images here\n      </DragBox>\n      <div className=\"button-wrapper\">\n        {images && <button onClick={() => {\n          setImages([])\n          setFilenames([])\n        }}>Remove All</button>}\n      </div>\n      <h5 style={{ marginTop: \"15px\" }}>Maximum {maxImageNumber} images</h5>\n    </div>\n  );\n};\nexport { DropArea as default, imagesAtom, filenamesAtom };\n","import React, { useEffect } from \"react\";\nimport * as tf from '@tensorflow/tfjs';\nimport {\n    useRecoilState,\n    atom,\n    useRecoilValue,\n} from \"recoil\";\nimport { imagesAtom } from \"components/DropArea\"\n\nvar model\nvar images\n\nconst loadModel = async () => {\n    model = await tf.loadLayersModel('https://cnn-repo.s3.ap-east-1.amazonaws.com/models/tfjs/model.json')\n    console.log(model)\n    return model\n}\n\nconst loadImageUrl = async (url) => {\n    return new Promise((resolve, reject) => {\n        const im = new Image()\n        im.src = url\n        im.onload = () => {\n            resolve(im)\n        }\n    })\n}\n\nconst predictionsAtom = atom({\n    key: 'predictions',\n    default: []\n})\n\nconst ImageClassifier = () => {\n    images = useRecoilValue(imagesAtom)\n    const [predictions, setPredictions] = useRecoilState(predictionsAtom)\n\n    const predict = async (images) => {\n        console.log(\"predict\")\n        console.log(images)\n\n        await Promise.all(images.map(async (image) => {\n            const img = await loadImageUrl(image)\n            const tensorImg = tf.browser.fromPixels(img).resizeNearestNeighbor([224, 224]).toFloat().expandDims();\n            const prediction = await model.predict(tensorImg).data();\n            return prediction\n        })).then((values) => {\n            setPredictions(values)\n        })\n    }\n\n    useEffect(() => {\n        if (model) {\n            predict(images)\n        }\n        else {\n            loadModel().then(() => {\n                /* In case the user drag images earlier than model load */\n                predict(images)\n            })\n        }\n    }, [images])\n\n    return (\n        <div></div>\n    )\n}\n\nexport { ImageClassifier as default, predictionsAtom };"],"sourceRoot":""}